%%
%% %CopyrightBegin%
%% 
%% Copyright Ericsson AB 1997-2009. All Rights Reserved.
%% 
%% The contents of this file are subject to the Erlang Public License,
%% Version 1.1, (the "License"); you may not use this file except in
%% compliance with the License. You should have received a copy of the
%% Erlang Public License along with this software. If not, it can be
%% retrieved online at http://www.erlang.org/.
%% 
%% Software distributed under the License is distributed on an "AS IS"
%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
%% the License for the specific language governing rights and limitations
%% under the License.
%% 
%% %CopyrightEnd%
%%
%%
%%%----------------------------------------------------------------------
%%% File    : handler_eqc.erl
%%%----------------------------------------------------------------------

-module(handler_eqc).
-vsn("1.0").

-behaviour(gen_event).

%% gen_event callbacks
-export([init/1, handle_event/2, handle_call/2, handle_info/2,
	 terminate/2, code_change/3]).

-record(state,{floors,elevs=[],events=[]}).
-record(elevator,{nr,floor}).

%%%----------------------------------------------------------------------
%%% Callback functions from gen_event
%%%----------------------------------------------------------------------

%% init([Floor, NFloors, EPids])
%%  Initializes the display, with the elevator initially at Floor and
%%  a total of NFloors floors. EPids is a list of the elevator control
%%  process pids.
%%----------------------------------------------------------------------
init([Floor, NFloors, NElevs]) ->
    State = 
      #state{floors= NFloors,
             elevs =
	     lists:map(fun(Elev) ->
		          #elevator{nr=Elev,floor=Floor}
		       end,lists:seq(1,NElevs))},
    os:putenv("eqctimeout","1"),
    {ok, State}.

%%----------------------------------------------------------------------
%% handle_event handles the sys events and dispatches the interesting ones
%% to the graphical elevator.
%%----------------------------------------------------------------------
handle_event({open, ENo} = Event, State) ->
    Elev = get_elev(ENo,State#state.elevs),
    %io:format("opened ~p\n",[ENo]),
    {ok, State#state{events = State#state.events++
                       [{open,Elev#elevator.nr,Elev#elevator.floor}]}};
handle_event({close, ENo} = Event, State) ->
    {ok, State};
handle_event({move, ENo, Dir} = Event, State) ->
    {ok, State};
handle_event({stopping, ENo} = Event, State) ->
    {ok, State};
handle_event({controller_started, ENo, EPid} = Event, State) ->
    {ok, State};
%%----------------------------------------------------------------------
%% ignore the following
%%----------------------------------------------------------------------
handle_event({approaching, ENo, Floor}, State) ->
    Elev = get_elev(ENo,State#state.elevs),
    NewState =  
      	State#state{elevs = (State#state.elevs--[Elev])++
                            [Elev#elevator{floor=Floor}]},
    {ok, NewState};
handle_event({stopped_at, ENo, Floor}, ElevGs) ->
    {ok, ElevGs};
handle_event({passing, ENo, Floor}, ElevGs) ->
    {ok, ElevGs};
handle_event({reset, ENo, _, Floor}, State) ->
    {ok, State};
%%----------------------------------------------------------------------
%% ...and so are events generated by ourselves.
%%----------------------------------------------------------------------
handle_event({f_button, Floor}, State) ->
    {ok, State#state{events = State#state.events++[{floor,Floor}]}};
handle_event({e_button, ENo, Floor}, State) ->
    {ok, State#state{events = State#state.events++[{elevator,ENo,Floor}]}}.

%%----------------------------------------------------------------------
%% handle_call not used
%%----------------------------------------------------------------------
handle_call(opened, State) ->
    {ok, State#state.events, State#state{events=[]}};
handle_call(Request, State) ->
    {ok, ok, State}.

%%----------------------------------------------------------------------
handle_info(_, State) ->
    {ok, State}.

%%----------------------------------------------------------------------
%% terminate has nothing to clean up.
%%----------------------------------------------------------------------
terminate(Reason, State) ->
    ok.

%%----------------------------------------------------------------------
%% code_change has no state to convert.
%%----------------------------------------------------------------------
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.

%%%----------------------------------------------------------------------
%%% Internal functions
%%%----------------------------------------------------------------------

get_elev(Nr,[Elev|Elevs]) ->
   case Elev#elevator.nr == Nr of
	true ->
		Elev;
	false ->
		get_elev(Nr,Elevs)
   end.

